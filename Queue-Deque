public static <T> Optional<T> of(T value)
Returns an Optional with the specified present non-null value.

NullPointerException - if value is null

public static <T> Optional<T> ofNullable(T value)
Returns an Optional describing the specified value, if non-null, otherwise returns an empty Optional.

Optionla<Empty>

ObjectName :: methodName

flatmap()  -> Intermediate (transformation)
---------

<R> Stream<R>	flatMap(Function<? super T,? extends Stream<? extends R>> mapper)
Returns a stream consisting of the results of replacing each element of this stream with the contents of a mapped stream produced by applying the provided mapping function to each element.

Stream (Stream)  -> Single Stream (flattening)


[[1, 3, 5, 7, 9], [0, 2, 4, 6, 8, 10]] List(List) 

[1, 3, 5, 7, 9, 0, 2, 4, 6, 8, 10] -> Single List by doing Flattening flatmap()

Before calling flatmap :[[1, 3, 5, 7, 9], [0, 2, 4, 6, 8, 10]]
After Calling flatmap :[1, 3, 5, 7, 9, 0, 2, 4, 6, 8, 10]

package com.demo.java8;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collector;
import java.util.stream.Collectors;

public class App {

	public static void main(String[] args) {

		List<Integer> evenNumbers = new ArrayList<>();
		evenNumbers.add(0);
		evenNumbers.add(2);
		evenNumbers.add(4);
		evenNumbers.add(6);
		evenNumbers.add(8);
		evenNumbers.add(10);
		
		List<Integer> oddNumbers = new ArrayList<>();
		oddNumbers.add(1);
		oddNumbers.add(3);
		oddNumbers.add(5);
		oddNumbers.add(7);
		oddNumbers.add(9);

		List<List<Integer>> list = new ArrayList<>();
		list.add(oddNumbers);
		list.add(evenNumbers);
		
		System.out.println("Before calling flatmap :"+list);
		
		List<Integer> collect = list.stream()
				.flatMap(t -> t.stream())
				.collect(Collectors.toList());
		System.out.println("After Calling flatmap :"+collect);	

	}

}


Queue and Deque
---------------

A collection designed for holding elements prior to processing.


Insert  	add(e)	    offer(e)
Remove  	remove()	poll()
Examine	    element()	peek()

Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner.

package com.demo.java8;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class App {

	public static void main(String[] args) {

		Queue<Integer> queue = new LinkedList<>();
		queue.add(10);
		queue.add(20);
		queue.add(30);
		queue.add(40);
		queue.add(50);
		queue.add(60);

		System.out.println(queue);

		queue.poll();

		System.out.println(queue);

	}

}


An unbounded priority queue based on a priority heap.

package com.demo.java8;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class App {

	public static void main(String[] args) {

		Queue<Integer> queue = new PriorityQueue<>();
		queue.add(1);
		queue.add(6);
		queue.add(2);
		queue.add(4);
		queue.add(3);
		queue.add(5);

		System.out.println(queue);

		Iterator<Integer> iterator = queue.iterator();
		while (iterator.hasNext()) {
			queue.poll();
			System.out.println(queue);
		}

	}

}

Result:
-------

[1, 3, 2, 6, 4, 5] - Priority Queue
[2, 3, 5, 6, 4] -> 1 
[3, 4, 5, 6] -> 2
[4, 6, 5] -> 3
[5, 6] -> 4
[6] -> 5
[] -> 6

package com.demo.java8;

import java.util.Iterator;
import java.util.LinkedList;
import java.util.PriorityQueue;
import java.util.Queue;
import java.util.concurrent.ConcurrentLinkedQueue;

public class App {

	public static void main(String[] args) {

		Queue<Integer> queue = new PriorityQueue<>();
		queue.add(10);
		queue.add(60);
		queue.add(20);
		queue.add(40);
		queue.add(35);
		queue.add(55);

		System.out.println(queue);

		Iterator<Integer> iterator = queue.iterator();
		while (iterator.hasNext()) {
			queue.poll();
			System.out.println(queue);
		}

	}

}


[10, 35, 20, 60, 40, 55]
[20, 35, 55, 60, 40]
[35, 40, 55, 60]
[40, 60, 55]
[55, 60]
[60]
[]


A linear collection that supports element insertion and removal at both ends. The name deque is short for "double ended queue" and is usually pronounced "deck".
 Most Deque implementations place no fixed limits on the number of elements they may contain, but this interface supports capacity-restricted deques as well as those with no fixed size limit.


Summary of Deque methods
First Element (Head)	Last Element (Tail)
Throws exception	Special value	Throws exception	Special value
Insert	addFirst(e)	offerFirst(e)	addLast(e)	offerLast(e)
Remove	removeFirst()	pollFirst()	removeLast()	pollLast()
Examine	getFirst()	peekFirst()	getLast()	peekLast()



package com.demo.java8;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Iterator;

public class App {

	public static void main(String[] args) {

		Deque<Integer> queue = new ArrayDeque<>();
		queue.add(10);
		queue.addFirst(20);
		queue.addLast(30);
		queue.add(40);
		queue.addFirst(50);

		System.out.println(queue);

		queue.poll();
		System.out.println(queue);

		queue.pollLast();
		System.out.println(queue);

		queue.pollFirst();
		System.out.println(queue);

	}

}
